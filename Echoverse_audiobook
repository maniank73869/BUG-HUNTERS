import gradio as gr
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
from gtts import gTTS
import io
import tempfile
import os
from datetime import datetime
import re

class ToneRewriterApp:
    def __init__(self):
        # Initialize the IBM Granite model
        self.model_name = "ibm-granite/granite-3.2-2b-instruct"
        print("Loading IBM Granite model...")
        self.tokenizer = AutoTokenizer.from_pretrained(self.model_name, trust_remote_code=True)
        self.model = AutoModelForCausalLM.from_pretrained(
            self.model_name,
            torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
            device_map="auto" if torch.cuda.is_available() else None,
            trust_remote_code=True
        )
        print("Model loaded successfully!")

        # Voice options mapping
        self.voice_options = {
            "Lisa (Female, Clear)": {"lang": "en", "tld": "com"},
            "Michael (Male, Professional)": {"lang": "en", "tld": "co.uk"},
            "Allison (Female, Warm)": {"lang": "en", "tld": "ca"}
        }

    def rewrite_text(self, original_text, target_tone):
        """Rewrite text using IBM Granite model with specified tone"""

        tone_prompts = {
            "Neutral": "Rewrite the following text in a neutral, objective tone while preserving all key information:",
            "Suspenseful": "Rewrite the following text to create suspense and tension, making it more dramatic and engaging:",
            "Inspiring": "Rewrite the following text in an inspiring, motivational tone that uplifts and encourages the reader:"
        }

        prompt = f"""<|system|>
You are an expert text rewriter. Your task is to rewrite text according to the specified tone while preserving the original meaning and key information.

<|user|>
{tone_prompts[target_tone]}

Original text: "{original_text}"

Please provide only the rewritten text, no explanations or additional commentary.

<|assistant|>
"""

        # Tokenize and generate
        inputs = self.tokenizer(prompt, return_tensors="pt", truncation=True, max_length=512)
        if torch.cuda.is_available():
            inputs = inputs.to(self.model.device)

        with torch.no_grad():
            outputs = self.model.generate(
                inputs["input_ids"],
                max_new_tokens=200,
                temperature=0.7,
                do_sample=True,
                pad_token_id=self.tokenizer.eos_token_id,
                attention_mask=inputs.get("attention_mask")
            )

        # Decode the response
        response = self.tokenizer.decode(outputs[0], skip_special_tokens=True)

        # Extract only the assistant's response
        if "<|assistant|>" in response:
            rewritten_text = response.split("<|assistant|>")[-1].strip()
        else:
            rewritten_text = response[len(prompt):].strip()

        # Clean up the response
        rewritten_text = re.sub(r'^["\']|["\']$', '', rewritten_text.strip())

        return rewritten_text if rewritten_text else original_text

    def generate_audio(self, text, voice_selection):
        """Generate audio from text using gTTS with voice selection"""
        try:
            voice_config = self.voice_options[voice_selection]

            # Create TTS object
            tts = gTTS(text=text, lang=voice_config["lang"], tld=voice_config["tld"], slow=False)

            # Create temporary file
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".mp3")
            tts.save(temp_file.name)

            return temp_file.name

        except Exception as e:
            print(f"Error generating audio: {e}")
            return None

    def process_text(self, original_text, target_tone, voice_selection):
        """Main processing function"""
        if not original_text.strip():
            return "Please enter some text to rewrite.", "", None

        # Rewrite text
        print(f"Rewriting text with {target_tone} tone...")
        rewritten_text = self.rewrite_text(original_text, target_tone)

        # Generate audio
        print(f"Generating audio with {voice_selection}...")
        audio_file = self.generate_audio(rewritten_text, voice_selection)

        return original_text, rewritten_text, audio_file

# Initialize the app
app = ToneRewriterApp()

# Create Gradio interface
def create_interface():
    with gr.Blocks(
        theme=gr.themes.Soft(),
        title="Tone-Adaptive Text Rewriter with Voice Narration"
    ) as demo:

        gr.Markdown("""
        # üé≠ Tone-Adaptive Text Rewriter with Voice Narration
        Transform your text into different tones and listen to high-quality voice narration!
        """)

        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### Input Settings")

                original_input = gr.Textbox(
                    label="üìù Original Text",
                    placeholder="Enter the text you want to rewrite...",
                    lines=5,
                    max_lines=10
                )

                tone_selector = gr.Radio(
                    choices=["Neutral", "Suspenseful", "Inspiring"],
                    label="üéØ Target Tone",
                    value="Neutral"
                )

                voice_selector = gr.Dropdown(
                    choices=list(app.voice_options.keys()),
                    label="üé§ Voice Selection",
                    value="Lisa (Female, Clear)"
                )

                process_btn = gr.Button("‚ú® Transform Text", variant="primary", size="lg")

        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### Side-by-Side Text Comparison")

                with gr.Row():
                    original_display = gr.Textbox(
                        label="üìÑ Original Text",
                        interactive=False,
                        lines=6,
                        max_lines=10
                    )

                    rewritten_display = gr.Textbox(
                        label="‚ú® Tone-Adapted Text",
                        interactive=False,
                        lines=6,
                        max_lines=10
                    )

        with gr.Row():
            with gr.Column():
                gr.Markdown("### üîä Voice Narration")
                audio_output = gr.Audio(
                    label="Generated Audio",
                    type="filepath",
                    interactive=False
                )

        # Event handlers
        process_btn.click(
            fn=app.process_text,
            inputs=[original_input, tone_selector, voice_selector],
            outputs=[original_display, rewritten_display, audio_output]
        )

        # Example inputs
        gr.Markdown("### üìö Example Inputs")

        examples = [
            [
                "The meeting will be held tomorrow at 3 PM in the conference room. Please bring your reports and be prepared to discuss the quarterly results.",
                "Suspenseful",
                "Michael (Male, Professional)"
            ],
            [
                "Learning to code can be challenging, but with practice and dedication, anyone can master programming skills.",
                "Inspiring",
                "Lisa (Female, Clear)"
            ]
        ]

        gr.Examples(
            examples=examples,
            inputs=[original_input, tone_selector, voice_selector],
            outputs=[original_display, rewritten_display, audio_output],
            fn=app.process_text
        )

        gr.Markdown("""
        ### üöÄ Features:
        - *Tone Adaptation*: Transform text into Neutral, Suspenseful, or Inspiring tones
        - *Voice Options*: Choose from Lisa, Michael, or Allison for narration
        - *Side-by-Side Comparison*: See original and adapted text together
        - *Audio Generation*: Download MP3 files for offline use
        - *Powered by*: IBM Granite 3.2-2B Instruct model
        """)

    return demo

# Launch the application
if __name__ == "__main__":
    print("üöÄ Starting Tone-Adaptive Text Rewriter...")

    # Create and launch interface
    demo = create_interface()
    demo.launch(
        share=True,  # Creates a public link
        debug=True,
        server_name="0.0.0.0",  # Important for Colab
        server_port=7860
    )
